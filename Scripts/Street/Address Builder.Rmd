---
title: "Address Builder"
author: "Clinton"
date: "18 February 2020"
output: html_document
---

### 1. Set Up

```{r message = FALSE, warning = FALSE}
library(dplyr)
library(stringr)
library(english)
library(purrr)
library(knitr)
library(kableExtra)

mn_output <- readRDS("../../Data/mn_output.rds")
```

<br>

### 2. Function

The function takes three variables `hn_1`, `best_match` and `street_type`, and concatenates an address suitable for geocoding. Two parameters are available for customising the output address. 

* The first parameter `spell_ave` defaults to FALSE, and converts numerics to words for streets where `street_type` is avenue. For example, "3 AVE" will be transformed to "THIRD AVE".

* The second parameter `suffix` defaults to FALSE, and adds ordinal indicators (e.g. st, nd, rd) for all streets. It is noted that this parameter takes places after `spell_ave` if both parameters are specified to be TRUE. For example, "3 AVE" will be transformed to "3RD AVE".

```{r}
# Helper function
string_Address = function(df, spell_ave, suffix) {
  
  # Variables used for Concatenate
  tmp_hn              = ifelse(!is.na(df$hn_1),
                               df$hn_1,
                               "")
  tmp_best_match      = df$best_match
  tmp_street_type     = ifelse(!is.na(df$tmp),
                               df$tmp,
                               "")
  
  # Spell Avenue numerics
  if (spell_ave == TRUE) {
    
    tmp_hn = ifelse(str_detect(tmp_street_type, 
                               pattern = "AVE"),
                    as.character(as.english(df$hn_1)),
                    tmp_hn)
  }
  
  # Adding suffixes to numerics
  if (suffix == TRUE) {
    
    tmp_ordinal = str_extract(tmp_hn, 
                              pattern = "[:digit:]+") %>%
      as.integer() %>%
      map_chr(., 
              function(x) {
                ifelse(!is.na(x),
                       scales::ordinal(x),
                       "")
              })

    tmp_hn = str_replace(tmp_hn, 
                         pattern = "[:digit:]+",
                         tmp_ordinal)
  }
  
  # Concatenate final output
  addr = paste(tmp_hn, 
               tmp_best_match, 
               tmp_street_type) %>%
    str_trim(side = "left") %>%
    toupper()
  return(addr)
}


# Main Function
build_Address = function(df, spell_ave = FALSE, suffix = FALSE) {
  
  # Placeholder until variable column of street type is made
  df$tmp = case_when(
    str_detect(df$street_add, pattern = " ST") ~ "ST",
    str_detect(df$street_add, pattern = " DR") ~ "DR",
    str_detect(df$street_add, pattern = " CIR") ~ "CIR",
    str_detect(df$street_add, pattern = " AVE") ~ "AVE",
    str_detect(df$street_add, pattern = " RD") ~ "RD"
  )
  
  # Will be removed when the column for tmp is replaced with the street type
  df$geo_addr = NA
  df$geo_addr = string_Address(df, spell_ave, suffix)
  
  return(df)
}
```

<br>

### 3. Examples

```{r}
examples = mn_output[c(1044,5098),]

base_function   = build_Address(examples)$geo_addr
spell_ave_true  = build_Address(examples, spell_ave = TRUE)$geo_addr
suffix_true     = build_Address(examples, suffix = TRUE)$geo_addr
both_true       = build_Address(examples, spell_ave = TRUE, suffix = TRUE)$geo_addr

cbind(base_function, spell_ave_true, suffix_true, both_true) %>%
  kable() %>%
  kable_styling()
```

<br>

### 4. Future Improvements

* Function is still a little buggy, and some `NA`s exist, but should improve when the `street_type` variable is produced
* `map` is performing slowly, and code needs to be optimised to run faster

<br>

***
